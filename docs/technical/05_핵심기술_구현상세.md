# System Informer 핵심기술 구현 상세

## 문서 정보
- **프로젝트명**: System Informer
- **문서 버전**: 1.0
- **작성일**: 2026-01-25

---

## 1. Native NT API 활용

### 1.1 개요

System Informer는 Windows의 비공개 Native NT API를 광범위하게 활용하여 일반 Win32 API로는 접근할 수 없는 시스템 정보를 수집합니다.

### 1.2 핵심 구현

**파일 위치**: `phlib/native.c`, `phnt/*.h`

```c
// 프로세스 정보 조회 (phlib/native.c:PhEnumProcesses)
NTSTATUS PhEnumProcesses(
    _Out_ PVOID *Processes
)
{
    NTSTATUS status;
    PVOID buffer;
    ULONG bufferSize = 0x8000;  // 초기 버퍼 크기

    // 버퍼 크기가 충분할 때까지 반복
    do {
        buffer = PhAllocate(bufferSize);
        status = NtQuerySystemInformation(
            SystemProcessInformation,
            buffer,
            bufferSize,
            &bufferSize
        );

        if (status == STATUS_INFO_LENGTH_MISMATCH) {
            PhFree(buffer);
            bufferSize *= 2;  // 버퍼 크기 증가
        }
    } while (status == STATUS_INFO_LENGTH_MISMATCH);

    *Processes = buffer;
    return status;
}
```

### 1.3 주요 시스템 정보 클래스

| 클래스 | 용도 | 구현 위치 |
|--------|------|-----------|
| SystemProcessInformation | 프로세스 목록 | `procprv.c` |
| SystemHandleInformation | 핸들 목록 | `hndlprv.c` |
| SystemModuleInformation | 커널 모듈 | `modprv.c` |
| SystemPerformanceInformation | 성능 정보 | `sysinfo.c` |

---

## 2. 커널 드라이버 통신

### 2.1 통신 아키텍처

```
User Mode                         Kernel Mode
┌──────────────┐                 ┌──────────────────┐
│ kphlib.dll   │ DeviceIoControl │ KSystemInformer  │
│              │────────────────►│     .sys         │
│ KphConnect() │                 │ KphDispatch()    │
└──────────────┘                 └──────────────────┘
```

### 2.2 드라이버 연결

**파일**: `kphlib/kphcomms.c`

```c
NTSTATUS KphConnect(
    _Out_ PKPH_COMMS_HANDLE Handle
)
{
    NTSTATUS status;
    HANDLE deviceHandle;
    UNICODE_STRING deviceName;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK ioStatusBlock;

    RtlInitUnicodeString(&deviceName, KPH_DEVICE_NAME);
    InitializeObjectAttributes(&objectAttributes, &deviceName,
        OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtOpenFile(
        &deviceHandle,
        FILE_READ_DATA | FILE_WRITE_DATA,
        &objectAttributes,
        &ioStatusBlock,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        0
    );

    if (NT_SUCCESS(status)) {
        Handle->DeviceHandle = deviceHandle;
    }

    return status;
}
```

### 2.3 메시지 기반 통신

**파일**: `KSystemInformer/comms.c`

```c
// 요청 처리 디스패치
NTSTATUS KphDispatchDeviceControl(
    _In_ PDEVICE_OBJECT DeviceObject,
    _Inout_ PIRP Irp
)
{
    PIO_STACK_LOCATION irpStack;
    ULONG ioControlCode;
    NTSTATUS status;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ioControlCode = irpStack->Parameters.DeviceIoControl.IoControlCode;

    switch (ioControlCode) {
        case KPH_QUERYPROCESSINFO:
            status = KphQueryProcessInfo(Irp);
            break;
        case KPH_OPENPROCESS:
            status = KphOpenProcess(Irp);
            break;
        case KPH_TERMINATEPROCESS:
            status = KphTerminateProcess(Irp);
            break;
        // ... 기타 핸들러
    }

    return status;
}
```

---

## 3. 프로세스 모니터링

### 3.1 프로세스 공급자 패턴

**파일**: `SystemInformer/procprv.c`

```c
// 프로세스 공급자 메인 루프
VOID PhProcessProviderUpdate(VOID)
{
    PSYSTEM_PROCESS_INFORMATION processes;
    PSYSTEM_PROCESS_INFORMATION process;

    // 1. 시스템에서 프로세스 정보 수집
    PhEnumProcesses(&processes);

    // 2. 각 프로세스 처리
    process = PH_FIRST_PROCESS(processes);
    while (process) {
        PPH_PROCESS_ITEM processItem;

        // 기존 프로세스인지 확인
        processItem = PhReferenceProcessItem(process->UniqueProcessId);

        if (processItem) {
            // 기존 프로세스 업데이트
            PhUpdateProcessItem(processItem, process);
            PhDereferenceObject(processItem);
        } else {
            // 새 프로세스 추가
            processItem = PhCreateProcessItem(process);
            PhAddProcessItem(processItem);

            // 새 프로세스 이벤트 발생
            PhInvokeCallback(&PhProcessAddedEvent, processItem);
        }

        process = PH_NEXT_PROCESS(process);
    }

    // 3. 종료된 프로세스 정리
    PhRemoveTerminatedProcesses();

    PhFree(processes);
}
```

### 3.2 CPU 사용률 계산

```c
// CPU 델타 계산 (procprv.c)
VOID PhCalculateProcessCpuUsage(
    _Inout_ PPH_PROCESS_ITEM ProcessItem,
    _In_ PSYSTEM_PROCESS_INFORMATION Process
)
{
    ULONG64 kernelDelta, userDelta, totalDelta;

    // 커널/사용자 시간 델타 계산
    kernelDelta = Process->KernelTime.QuadPart -
                  ProcessItem->KernelTime.QuadPart;
    userDelta = Process->UserTime.QuadPart -
                ProcessItem->UserTime.QuadPart;
    totalDelta = kernelDelta + userDelta;

    // CPU 사용률 계산 (시스템 전체 시간 대비)
    ProcessItem->CpuUsage = (FLOAT)totalDelta /
                           PhCpuTotalCycleDelta /
                           PhSystemBasicInformation.NumberOfProcessors;

    // 값 저장
    ProcessItem->KernelTime.QuadPart = Process->KernelTime.QuadPart;
    ProcessItem->UserTime.QuadPart = Process->UserTime.QuadPart;
}
```

---

## 4. 메모리 관리 시스템

### 4.1 참조 카운팅 객체

**파일**: `phlib/ref.c`

```c
// 객체 헤더 구조
typedef struct _PH_OBJECT_HEADER {
    union {
        struct {
            USHORT TypeIndex;
            UCHAR Flags;
            UCHAR Reserved;
            LONG RefCount;
        };
        ULONG_PTR Alignment;
    };
} PH_OBJECT_HEADER;

// 참조 증가
VOID PhReferenceObject(
    _In_ PVOID Object
)
{
    PPH_OBJECT_HEADER header = PhObjectToObjectHeader(Object);
    InterlockedIncrement(&header->RefCount);
}

// 참조 감소 (0이면 해제)
VOID PhDereferenceObject(
    _In_ PVOID Object
)
{
    PPH_OBJECT_HEADER header = PhObjectToObjectHeader(Object);

    if (InterlockedDecrement(&header->RefCount) == 0) {
        PhpFreeObject(Object);
    }
}
```

### 4.2 문자열 관리

**파일**: `phlib/basesup.c`

```c
// 문자열 생성
PPH_STRING PhCreateString(
    _In_ PWSTR Buffer
)
{
    return PhCreateStringEx(Buffer, wcslen(Buffer) * sizeof(WCHAR));
}

PPH_STRING PhCreateStringEx(
    _In_opt_ PWCHAR Buffer,
    _In_ SIZE_T Length
)
{
    PPH_STRING string;

    string = PhCreateObject(
        FIELD_OFFSET(PH_STRING, Buffer) + Length + sizeof(UNICODE_NULL),
        PhStringType
    );

    string->Length = Length;
    if (Buffer) {
        memcpy(string->Buffer, Buffer, Length);
    }
    string->Buffer[Length / sizeof(WCHAR)] = UNICODE_NULL;

    return string;
}
```

---

## 5. GUI 트리뷰 컨트롤

### 5.1 TreeNew 컨트롤

**파일**: `phlib/treenew.c`

고성능 가상화된 트리/리스트 컨트롤로, 수천 개의 항목을 효율적으로 표시합니다.

```c
// 컨트롤 생성
HWND PhCreateTreeNewControl(
    _In_ HWND ParentWindow,
    _In_ INT_PTR Id
)
{
    return CreateWindow(
        PH_TREENEW_CLASSNAME,
        NULL,
        WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | WS_TABSTOP,
        0, 0, 0, 0,
        ParentWindow,
        (HMENU)Id,
        PhInstanceHandle,
        NULL
    );
}

// 컬럼 추가
VOID PhAddTreeNewColumn(
    _In_ HWND TreeNewHandle,
    _In_ ULONG Id,
    _In_ BOOLEAN Visible,
    _In_ PWSTR Text,
    _In_ ULONG Width
)
{
    PH_TREENEW_COLUMN column;

    memset(&column, 0, sizeof(column));
    column.Id = Id;
    column.Visible = Visible;
    column.Text = Text;
    column.Width = Width;

    TreeNew_AddColumn(TreeNewHandle, &column);
}
```

### 5.2 가상화 렌더링

```c
// 노드 콜백 (필요할 때만 데이터 요청)
BOOLEAN ProcessTreeNewCallback(
    _In_ HWND hwnd,
    _In_ PH_TREENEW_MESSAGE Message,
    _In_opt_ PVOID Parameter1,
    _In_opt_ PVOID Parameter2,
    _In_opt_ PVOID Context
)
{
    switch (Message) {
        case TreeNewGetChildren:
            // 자식 노드 반환 (트리 구조)
            return GetProcessChildren(Parameter1, Parameter2);

        case TreeNewGetCellText:
            // 셀 텍스트 반환
            return GetProcessCellText(Parameter1, Parameter2);

        case TreeNewSortChanged:
            // 정렬 변경
            SortProcessList();
            return TRUE;
    }

    return FALSE;
}
```

---

## 6. 플러그인 시스템

### 6.1 플러그인 인터페이스

**파일**: `SystemInformer/include/phplug.h`

```c
// 플러그인 정보 구조체
typedef struct _PH_PLUGIN_INFORMATION {
    PWSTR Name;
    PWSTR Author;
    PWSTR Description;
    PWSTR Url;
    ULONG Version;
    ULONG InterfaceVersion;
} PH_PLUGIN_INFORMATION;

// 플러그인 필수 내보내기 함수
typedef BOOLEAN (NTAPI *PPH_PLUGIN_LOAD)(
    _In_ PPH_PLUGIN Plugin,
    _In_ ULONG SystemServiceNumber
);
```

### 6.2 플러그인 로딩

**파일**: `SystemInformer/plugin.c`

```c
BOOLEAN PhLoadPlugin(
    _In_ PWSTR FileName
)
{
    HMODULE moduleHandle;
    PPH_PLUGIN_LOAD loadFunction;
    PPH_PLUGIN plugin;

    // DLL 로드
    moduleHandle = LoadLibrary(FileName);
    if (!moduleHandle)
        return FALSE;

    // 초기화 함수 찾기
    loadFunction = (PPH_PLUGIN_LOAD)GetProcAddress(
        moduleHandle, "PhPluginLoad");

    if (!loadFunction) {
        FreeLibrary(moduleHandle);
        return FALSE;
    }

    // 플러그인 객체 생성
    plugin = PhCreatePlugin(FileName, moduleHandle);

    // 플러그인 초기화 호출
    if (!loadFunction(plugin, PhSystemServiceNumber)) {
        PhDestroyPlugin(plugin);
        return FALSE;
    }

    // 플러그인 목록에 추가
    PhAddPlugin(plugin);

    return TRUE;
}
```

### 6.3 콜백 등록

```c
// 플러그인에서 콜백 등록
VOID MyPluginInitialize(
    _In_ PPH_PLUGIN Plugin
)
{
    // 프로세스 추가 이벤트 구독
    PhRegisterCallback(
        &PhProcessAddedEvent,
        OnProcessAdded,
        NULL,
        &ProcessAddedCallbackRegistration
    );

    // 메뉴 항목 추가
    PhRegisterCallback(
        &PhMenuShowingEvent,
        OnMenuShowing,
        NULL,
        &MenuShowingCallbackRegistration
    );
}
```

---

## 7. ETW 이벤트 추적

### 7.1 ETW 세션 관리

**파일**: `plugins/ExtendedTools/etwmon.c`

```c
// ETW 세션 시작
NTSTATUS EtStartEtwSession(VOID)
{
    NTSTATUS status;
    TRACEHANDLE sessionHandle;
    EVENT_TRACE_PROPERTIES properties;

    memset(&properties, 0, sizeof(properties));
    properties.Wnode.BufferSize = sizeof(properties);
    properties.Wnode.Flags = WNODE_FLAG_TRACED_GUID;
    properties.LogFileMode = EVENT_TRACE_REAL_TIME_MODE;
    properties.MinimumBuffers = 4;
    properties.MaximumBuffers = 64;
    properties.BufferSize = 64;  // KB

    status = StartTrace(
        &sessionHandle,
        L"SystemInformerEtwSession",
        &properties
    );

    if (NT_SUCCESS(status)) {
        EtSessionHandle = sessionHandle;

        // 공급자 활성화
        EnableTraceEx2(
            sessionHandle,
            &DiskIoGuid,
            EVENT_CONTROL_CODE_ENABLE_PROVIDER,
            TRACE_LEVEL_INFORMATION,
            0, 0, 0, NULL
        );
    }

    return status;
}
```

### 7.2 이벤트 처리

```c
// 이벤트 콜백
VOID WINAPI EtEtwEventCallback(
    _In_ PEVENT_RECORD EventRecord
)
{
    if (IsEqualGUID(&EventRecord->EventHeader.ProviderId, &DiskIoGuid)) {
        // 디스크 I/O 이벤트 처리
        ProcessDiskIoEvent(EventRecord);
    }
    else if (IsEqualGUID(&EventRecord->EventHeader.ProviderId, &TcpIpGuid)) {
        // 네트워크 이벤트 처리
        ProcessNetworkEvent(EventRecord);
    }
}

VOID ProcessDiskIoEvent(
    _In_ PEVENT_RECORD EventRecord
)
{
    PDISK_IO_EVENT data = (PDISK_IO_EVENT)EventRecord->UserData;
    ULONG processId = EventRecord->EventHeader.ProcessId;

    // 프로세스별 I/O 통계 업데이트
    PPH_PROCESS_ITEM processItem = PhReferenceProcessItem(
        UlongToHandle(processId));

    if (processItem) {
        InterlockedAdd64(&processItem->DiskReadBytes, data->TransferSize);
        PhDereferenceObject(processItem);
    }
}
```

---

## 8. 심볼 해석 시스템

### 8.1 심볼 공급자

**파일**: `phlib/symprv.c`

```c
// 심볼 초기화
BOOLEAN PhSymbolProviderInitialize(VOID)
{
    // DbgHelp 초기화
    SymSetOptions(
        SYMOPT_UNDNAME |
        SYMOPT_DEFERRED_LOADS |
        SYMOPT_LOAD_LINES
    );

    // 심볼 경로 설정
    SymSetSearchPath(
        NtCurrentProcess(),
        L"srv*C:\\Symbols*https://msdl.microsoft.com/download/symbols"
    );

    return SymInitialize(NtCurrentProcess(), NULL, FALSE);
}
```

### 8.2 주소 해석

```c
// 주소에서 심볼 이름 가져오기
PPH_STRING PhGetSymbolFromAddress(
    _In_ HANDLE ProcessHandle,
    _In_ ULONG64 Address
)
{
    SYMBOL_INFO_PACKAGE symbolInfo;
    DWORD64 displacement;

    symbolInfo.si.SizeOfStruct = sizeof(SYMBOL_INFO);
    symbolInfo.si.MaxNameLen = MAX_SYM_NAME;

    if (SymFromAddr(ProcessHandle, Address, &displacement, &symbolInfo.si)) {
        // 모듈!함수+오프셋 형식
        return PhFormatString(
            L"%s!%S+0x%I64x",
            ModuleName,
            symbolInfo.si.Name,
            displacement
        );
    }

    return NULL;
}
```

---

## 9. 보안 및 검증

### 9.1 서명 검증

**파일**: `phlib/verify.c`

```c
// Authenticode 서명 검증
VERIFY_RESULT PhVerifyFile(
    _In_ PWSTR FileName,
    _Out_opt_ PPH_STRING *SignerName
)
{
    WINTRUST_DATA trustData;
    WINTRUST_FILE_INFO fileInfo;
    GUID actionGuid = WINTRUST_ACTION_GENERIC_VERIFY_V2;
    LONG status;

    memset(&fileInfo, 0, sizeof(fileInfo));
    fileInfo.cbStruct = sizeof(fileInfo);
    fileInfo.pcwszFilePath = FileName;

    memset(&trustData, 0, sizeof(trustData));
    trustData.cbStruct = sizeof(trustData);
    trustData.dwUIChoice = WTD_UI_NONE;
    trustData.dwUnionChoice = WTD_CHOICE_FILE;
    trustData.pFile = &fileInfo;

    status = WinVerifyTrust(NULL, &actionGuid, &trustData);

    if (status == ERROR_SUCCESS) {
        if (SignerName) {
            *SignerName = PhGetSignerName(&trustData);
        }
        return VrTrusted;
    }

    return VrUntrusted;
}
```

### 9.2 드라이버 클라이언트 검증

**파일**: `KSystemInformer/verify.c`

```c
// 클라이언트 프로세스 검증
NTSTATUS KphVerifyClient(
    _In_ PEPROCESS Process
)
{
    NTSTATUS status;
    PUNICODE_STRING imageName;
    UCHAR hash[32];

    // 프로세스 이미지 경로 가져오기
    status = SeLocateProcessImageName(Process, &imageName);
    if (!NT_SUCCESS(status))
        return status;

    // 이미지 해시 계산
    status = KphHashFile(imageName, hash);
    if (!NT_SUCCESS(status))
        return status;

    // 알려진 해시와 비교
    if (RtlEqualMemory(hash, KphTrustedHash, sizeof(hash))) {
        return STATUS_SUCCESS;
    }

    return STATUS_ACCESS_DENIED;
}
```

---

## 10. 동적 데이터 시스템

### 10.1 Windows 버전별 오프셋 관리

**파일**: `kphlib/kphdyn.c`, `kphlib/kphdyn.xml`

```c
// 동적 데이터 로드
NTSTATUS KphLoadDynamicData(VOID)
{
    NTSTATUS status;
    RTL_OSVERSIONINFOEXW versionInfo;
    PKPH_DYN_DATA dynData;

    // 현재 Windows 버전 가져오기
    RtlGetVersion(&versionInfo);

    // 해당 버전의 동적 데이터 찾기
    dynData = KphFindDynamicData(
        versionInfo.dwBuildNumber,
        versionInfo.dwMajorVersion,
        versionInfo.dwMinorVersion
    );

    if (!dynData) {
        return STATUS_NOT_SUPPORTED;
    }

    // 오프셋 적용
    KphDynEprocessUniqueProcessId = dynData->EprocessUniqueProcessId;
    KphDynEprocessToken = dynData->EprocessToken;
    KphDynEprocessImageFileName = dynData->EprocessImageFileName;
    // ...

    return STATUS_SUCCESS;
}
```

### 10.2 XML 데이터 구조

```xml
<!-- kphdyn.xml 예시 -->
<DynamicData>
  <Version Build="22621" Revision="1" Name="Windows 11 22H2">
    <Offsets>
      <EPROCESS>
        <UniqueProcessId>0x440</UniqueProcessId>
        <ActiveProcessLinks>0x448</ActiveProcessLinks>
        <Token>0x4b8</Token>
        <ImageFileName>0x5a8</ImageFileName>
        <Peb>0x550</Peb>
      </EPROCESS>
      <ETHREAD>
        <Cid>0x478</Cid>
        <StartAddress>0x4a0</StartAddress>
      </ETHREAD>
    </Offsets>
  </Version>
</DynamicData>
```

---

## 11. 동기화 기법

### 11.1 Queued Lock (경량 잠금)

**파일**: `phlib/queuedlock.c`

```c
// 큐 기반 스핀락 - 공정하고 빠름
typedef struct _PH_QUEUED_LOCK {
    ULONG_PTR Value;
} PH_QUEUED_LOCK;

VOID PhAcquireQueuedLockExclusive(
    _Inout_ PPH_QUEUED_LOCK Lock
)
{
    ULONG_PTR value;
    ULONG_PTR newValue;
    ULONG spinCount;

    spinCount = PhQueuedLockSpinCount;

    while (TRUE) {
        value = Lock->Value;

        if (!(value & PH_QUEUED_LOCK_OWNED)) {
            newValue = value | PH_QUEUED_LOCK_OWNED;
            if (InterlockedCompareExchangePointer(
                    &Lock->Value, newValue, value) == value) {
                return;  // 잠금 획득 성공
            }
        }

        if (spinCount-- == 0) {
            // 대기 큐에 추가
            PhpBlockOnQueuedLock(Lock, value);
            spinCount = PhQueuedLockSpinCount;
        }

        YieldProcessor();
    }
}
```

### 11.2 Rundown Protection

```c
// 객체가 사용 중일 때 안전하게 해제 대기
BOOLEAN PhAcquireRundownProtection(
    _Inout_ PPH_RUNDOWN_PROTECT Protection
)
{
    ULONG_PTR value;
    ULONG_PTR newValue;

    value = Protection->Value;

    if (value & PH_RUNDOWN_ACTIVE) {
        return FALSE;  // 이미 rundown 중
    }

    newValue = value + PH_RUNDOWN_REF_INC;

    return InterlockedCompareExchangePointer(
        &Protection->Value, newValue, value) == value;
}
```

---

## 12. 성능 최적화 기법

### 12.1 지연 로딩

```c
// 필요할 때만 심볼 로드
VOID PhLoadSymbolsDeferred(
    _In_ PPH_PROCESS_ITEM ProcessItem
)
{
    if (!ProcessItem->SymbolsLoaded) {
        // 백그라운드 스레드에서 심볼 로드
        PhQueueItemWorkQueue(
            PhGetGlobalWorkQueue(),
            LoadSymbolsWorkItem,
            ProcessItem
        );
    }
}
```

### 12.2 캐싱

```c
// 해시 테이블 기반 프로세스 캐시
static PH_HASHTABLE ProcessHashtable;

PPH_PROCESS_ITEM PhReferenceProcessItem(
    _In_ HANDLE ProcessId
)
{
    PPH_PROCESS_ITEM *entry;

    PhAcquireQueuedLockShared(&ProcessHashtableLock);

    entry = PhFindEntryHashtable(
        &ProcessHashtable,
        &ProcessId
    );

    if (entry) {
        PhReferenceObject(*entry);
        PhReleaseQueuedLockShared(&ProcessHashtableLock);
        return *entry;
    }

    PhReleaseQueuedLockShared(&ProcessHashtableLock);
    return NULL;
}
```

---

## 요약

System Informer의 핵심 기술들:

| 기술 | 목적 | 구현 위치 |
|------|------|-----------|
| Native NT API | 저수준 시스템 접근 | `phlib/native.c` |
| 커널 드라이버 | 권한 상승, 보호 우회 | `KSystemInformer/` |
| 참조 카운팅 | 메모리 관리 | `phlib/ref.c` |
| TreeNew 컨트롤 | 고성능 UI | `phlib/treenew.c` |
| 플러그인 시스템 | 확장성 | `SystemInformer/plugin.c` |
| ETW 추적 | 이벤트 모니터링 | `plugins/ExtendedTools/` |
| 심볼 해석 | 디버그 정보 | `phlib/symprv.c` |
| 동적 데이터 | 버전 호환성 | `kphlib/kphdyn.c` |
